section code

export div
func_local div res n d ; (div_t *res, int numerator, int denominator)
	aload res -3 d
	aload res -2 n
	aload res -1 res
	div n d (sp)
	astore res 0 (sp)
	mod n d (sp)
	astore res 1 (sp)
	return 0

export udiv
;
; Goal: given n an d, calculate quotient q (n/d) and remained r (n%d) using
;       unsigned arithmetic (modulo 2**32), but implemented using Glulx's signed
;	arithmetic instructions.
;
; Approach:
;  if n gt 0 and d gt 0:
;    return q = n/d, r = n%d
;    (n and d are small enough to use standard signed division/modulo)
;  if n ltu d:
;    return q = 0, r = n
;  else if d lt 0:  /* implies n < 2d */
;    return q = 1, r = n - d
;  else:
;     q = ((n rshiftu 1)/d) lshiftu 1
;     r = n - (q mul d)
;     if r geu d:
;       q = q + 1
;       r = r - d
;     return q, r
;
func_local udiv res n d q tmp ; (udiv_t *res, unsigned num, unsigned den)
	aload res -3 d
	aload res -2 n
	aload res -1 res
	bitor n d tmp
	jlt tmp 0 :udiv_hard
	div n d tmp
	astore res 0 tmp
	mod n d tmp
	astore res 1 tmp
	return 0
:udiv_hard
	jltu n d :udiv_q0
	jlt  d 0 :udiv_q1
	ushiftr n 1 tmp
	div tmp d tmp
	shiftl tmp 1 q
	mul q d tmp
	sub n tmp n
	jltu n d :udiv_end
	add q 1 q
	sub n d n
:udiv_end
	astore res 0 q
	astore res 1 n
	return 0
:udiv_q0
	astore res 0 0
	astore res 1 n
	return 0
:udiv_q1
	astore res 0 1
	sub n d n
	astore res 1 n
	return 0

; Calls to the _udiv and _umod functions are generated by the compiler.
; NB. the _udiv and _umod functions do not follow the usual calling convention
;     but instead receive their arguments directly.

export _udiv
func_local _udiv n d q tmp
	jltu n d 0
	jlt  d 0 1
	ushiftr n 1 tmp
	div tmp d tmp
	shiftl tmp 1 q
	mul q d tmp
	sub n tmp n
	jltu n d :_udiv_end
	add q 1 q
:_udiv_end
	return q

export _umod
func_local _umod n d q tmp
	jltu n d :_umod_q0  ; n/d == 0  =>  n%d = n
	jlt  d 0 :_umod_q1  ; n/d == 1  =>  n%d = n - d
	ushiftr n 1 tmp
	div tmp d tmp
	shiftl tmp 1 q
	mul q d tmp
	sub n tmp n
	jltu n d :_umod_q0
:_umod_q1
	sub n d n
:_umod_q0
	return n
