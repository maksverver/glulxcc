Each object file is stored in a Glulx object chunk, which contains exactly one
header chunk, code table, import table, export table and cross references table,
in that specific order.

Note that a file may contain multiple object chunks, so compiled object files
can be concatenated into simple archives. All number are stored in in big endian
byte-order. All chunks sizes are multiples of 4, so all chunks are aligned to
four-byte boundaries.

Glulx Object chunk
    4   FORM
    4   remaining chunk size
    4   GLUO
    -   remaining chunk data

Header chunk
    4   HEAD
    4   header chunk size (8)
    4   version (xxxx.yy.zz); 1.0.0 == 0x00010000
    4   minimum stack size required

Code table chunk
    4   CODE
    4   code table chunk size (multiple of 4)
    4   number of sections (N)
    For each section:
        4   section type (0:code, 1:data, 2:vcode, 3:vdata, 4:bss)
        4   data size (D) padded to 4 bytes
        2   reserved (0)
        2   data alignment (0: linker decides)
        0/D section data
            (if section type == bss, no section data is included)
    End of section entry

Import table chunk
    4   IMPO
    4   import table chunk size (S; multiple of 4)
    4   number of entries (N)
    For each entry:
    4   name (offset relative to start of import table)
    End of entry
 S-4-4N string data (ends with a zero)

Export table
    4   EXPO
    4   export table chunk size (S; multiple of 4)
    4   number of entries (N)
    For each entry:
    4   name (offset relative to start of export table)
    4   section
    4   offset
    End of entry
S-4-12N string data (ends with a zero)

Cross-references chunk
    4   XREF
    4   cross-references chunk size (S; multiple of 4)
    4   number of entries (N)
    For each entry:
    4   patched section
    4   patched offset
    4   referenced section (for internal references)
    4   referenced offset  (for internal references)
        (For external references, the referenced section is set to -1, and the
         referenced offset is an index into the import table instead.)
    End of entry

The linker takes a series of Glulx object files and creates a single executable
module. This starts by loading all modules and resolving imported symbols. Then,
the sections containing the start symbol (by default: "main") and the (optional)
initial decoding table ("decodingtbl") are looked up, and a reachability
analysis is performed from the section containing the start symbol.

All reachable sections are reordered by:
 1. section type (ROM: code, data, RAM: vcode, vdata, EXT: bss)
 2. object file order on the command line
 3. section index in the original object file

Now the section addresses are calculated. Sections are aligned to their
respective boundaries.  Extra padding is inserted after the last code/data,
vcode/vdata and bss sections to align the ROM, RAM and EXT sections to 256
bytes.

Finally, cross-references are resolved. For each cross reference, the 32-bit
referenced address is added to whatever data is already present at the patched
offset (in big-endian byte order); this will often be zero, but it doesn't have
to be!

Now all sections have fixed addresses and all cross-references have been
resolved. The compiler constructs the compiler 
    ROM:
        header
        code sections
        data sections
    RAM:
        vcode sections
        vdata sections
    EXTSTART:
        bss sections
    EXTEND.

Unsupported features:
 - RAM-relative addresses
 - cross-section relative jumps

